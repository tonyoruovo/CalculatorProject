/**
 * 
 */
package mathaid.calculator.base.typeset;

import java.util.List;

/*
 * Date: 13 Nov 2023 -----------------------------------------------------------
 * Time created: 11:00:05 ---------------------------------------------------
 * Package: mathaid.calculator.base.typeset ------------------------------------------------
 * Project: CalculatorProject ------------------------------------------------
 * File: LinkedSegment.java ------------------------------------------------------
 * Class name: LinkedSegment ------------------------------------------------
 */
/**
 * A {@code Segment} implemented as a forward linking tree. Each {@code LinkedSegment} is a
 * node, where {@link LinkedSegment#getSibling} is used to get the sibling of
 * the node from which it was called and {@link LinkedSegment#getChildren} gets
 * the children.
 * <p>A {@code LinkedSegment} is a tree (represented like an abstract syntax tree) which can exist
 * independent of it's siblings. It may have an image (which is the face value of the
 * {@code LinkedSegment}) and also children (which are themselves {@code LinkedSegment}s). A {@code LinkedSegment} may or
 * may not be independent of it's children, this is entirely dependent on the
 * implementation. Each child node is ordered and this ordering will not change
 * throughout the lifetime of the {@code LinkedSegment}. This tree can be traversed
 * horizontally using {@link #getSibling}, only through such an operation can the
 * top level {@code LinkedSegment}s be reached. Top level {@code LinkedSegment}s are
 * nodes within the {@code LinkedSegment} tree that don't have a parent i.e they are
 * not the result of the calling {@link #getChildren()}. Using {@code LinkedSegment.getSibling}
 * to access a node is called horizontal traversal of the tree.
 * <p>
 * The {@code LinkedSegment} tree has the focus property
 * which can only be held by 1 {@code LinkedSegment} at a time. When a {@code LinkedSegment} holds the focus
 * of the {@code LinkedSegment} tree, all other {@code LinkedSegment}s (including the holder's children) will
 * return false if queried for the focus. Note that certain applications
 * may use the focus property to display visual caret for viewers of math.
 * There is also the error property, which
 * may indicate that there is a syntactic error in a {@code LinkedSegment} which will cause
 * evaluation (i.e when strings generated by {@link LinkedSegment#toString(Appendable, Log, java.util.List)}
 * are evaluated by a CAS such as Symja) to fail. There can be multiple errors
 * within a tree but errors are not inherited by child nodes neither are they
 * passed onto siblings.
 * <p>Segments are immutable, therefore, all
 * methods that perform some operation will return a new {@code LinkedSegment}, with all the
 * changes that the operation should have made to the current {@code LinkedSegment} reflected
 * in the returned {@code LinkedSegment}, meanwhile no mutation of the current {@code LinkedSegment} is
 * effective. A common example of this are the {@code setXxx} methods which do
 * not actually mutate the {@code LinkedSegment} on which they were called.
 * <p>
 * {@code LinkedSegment} objects are used for representing the visual AST of
 * mathematical languages such as MathML, AsciiMath, TeX etc. Like in HTML,
 * these Abstract Syntax Trees can be styled with various visual effects so as
 * to appear visually appealing. Consider the following:
 * <div>
 *	 <svg viewbox="0 0 200 50">
 *		 	<rect x="13" rx="2" y="0" ry="2" width="40" stroke-width=".5" stroke="red" fill="none" height="50" />
 *		 	<rect x="72" rx="1" y="15" ry="1" width="15" stroke-width=".5" stroke="red" fill="none" height="15" />
 *		 	<rect x="110" rx="1" y="0" ry="1" width="55" stroke-width=".5" stroke="red" fill="none" height="50" />
 *		 	<text x="25" y="12" fill="black" style="font-size:10px;font-family:serif;font-weight:400;font-style:oblique;">n</text>
 *		 	<text x="20" y="35" fill="black" style="font-size:30px;font-family:serif;font-weight:400;">&#x03A3;</text>
 *		 	<text x="20" y="45" fill="black" style="font-size:10px;font-family:serif;font-weight:400;font-style:oblique;">i=</text>
 *		 	<text x="30" y="45" fill="black" style="font-size:10px;font-family:serif;font-weight:400;">3</text>
 *		 	<text x="40" y="28" fill="black" style="font-size:15px;font-family:serif;font-weight:400;font-style:oblique;">i</text>
 *		 	<text x="45" y="20" fill="black" style="font-size:10px;font-family:serif;font-weight:400;font-style:oblique;">n</text>
 *		 	<text x="75" y="28" fill="black" style="font-size:15px;font-family:serif;font-weight:400;">+</text>
 *		 	<text x="120" y="20" fill="black" style="font-size:15px;font-family:serif;font-weight:400;">&pm;</text>
 *		 	<text x="130" y="20" fill="black" style="font-size:15px;font-family:serif;font-weight:400;">3</text>
 *		 	<text x="137" y="20" fill="black" style="font-size:15px;font-family:serif;font-weight:400;font-style:oblique;">x</text>
 *		 	<text x="145" y="14" fill="black" style="font-size:10px;font-family:serif;font-weight:400;">2</text>
 *		 	<line x1="117" y1="23" x2="157" y2="23" style="stroke:black;stroke-width:1"/>
 *		 	<text x="115" y="37" fill="black" style="font-size:13px;font-family:serif;font-weight:400;">&#x221A;</text>
 *		 	<line x1="121.595" y1="25" x2="155" y2="25" style="stroke:black;stroke-width:.5"/>
 *		 	<text x="123" y="35" fill="black" style="font-size:13px;font-family:serif;font-weight:400;">log</text>
 *		 	<text x="140" y="38" fill="black" style="font-size:9px;font-family:serif;font-weight:400;font-style:oblique;">y</text>
 *		 	<text x="145" y="35" fill="black" style="font-size:13px;font-family:serif;font-weight:400;font-style:oblique;">n</text>
 *	 </svg>
 * </div>
 * All maths within red boxes represent top-level {@code LinkedSegment}s which are siblings of each other.
 * The above visuals can be achieved by doing:
 * <pre>
 * 	<code>
 * 		DigitPunc def = new DigitPunc();
 * 		LinkedSegment upper = Segments.freeVariable("n", "n");
 * 		LinkedSegment lower = Segments.freeVariable("i", "i");
 * 		LinkedSegment index = Digits.integer('3', def);
 * 		LinkedSegment function = Segments.pow(lower, upper);
 * 		SegmentBuilder formula = new SegmentBuilder(Segments.sum(index, lower, upper, function))//instantiates the first index
 * 										.append(Segments.operator("+", "+"))//appends the second index
 * 										.append(
 * 											Segments.fraction(
 * 												new SegmentBuilder(Segments.operator("±", "±"))
 * 													.append(Digits.integer('3', def))
 * 													.append(Segments.pow(
 * 														Segments.freeVariable("x", "x"),
 * 														Digits.integer('2', def))
 * 													).toSegment(),
 * 												Segments.sqrt(
 * 														Segments.logxy(Segments.freeVariable("y", "y"),
 * 														Segments.freeVariable("n", "n"))
 * 												)
 * 											)
 * 										);//the third index
 * 		Appendable out = System.out;
 * 		List<Integer> caret = new ArrayList<>();
 * 		caret.add(-1);
 *		/** Convert to a TeX string that can be displayed using MathJax or any other display engines *&sol;
 * 		formula.toSegment().format(out, Formatter.empty(), caret);// \sum\limits_{3 =i }^{n }\,i ^{n }+ \frac{±3x ^{2 } }{ \sqrt{ \log_{y } \left(n \right) }}
 * 		out.println();
 * 		caret.clear();
 * 		caret.add(-1);
 *		/** Convert to a string that can be evaluated by the Symja evaluator *&sol;
 * 		formula.toSegment().toString(out, null, caret);// Sum[i ^(n ) ,{3 ,i ,n }]+ Rational[�3*x ^(2 ) , Sqrt[ Log[n ,y ] ] ]
 * 	</code>
 * </pre>
 * 
 * The first index can be retrieved by: <code>LinkedSegment head = formula.toSegment();</code>. This is possible because the first index is always
 * the head. Subsequent indexes can also be retrieved by calling {@link #getSibling} e.g:
 * <pre>
 * 	<code>
 * 		LinkedSegment index1 = head.getSibling();//second index
 * 		LinkedSegment index2 = index1.getSibling();//third index
 * 		LinkedSegment index3 = index2.getSibling();//null, there is no 4th index
 * 	</code>
 * </pre>
 * <p>A special implementation of this interface is the {@linkplain mathaid.calculator.base.typeset.Empty empty {@code LinkedSegment}}, which runs parallel
 * the concept of the empty string {@code ""}.
 * <p>Note that {@code LinkedSegment}s are also constructed using {@link mathaid.calculator.base.evaluator.parser.expression.EvaluatableExpression#evaluate EvaluatableExpression.evaluate}.
 * 
 * @author Oruovo Anthony Etineakpopha
 * @email tonyoruovo@gmail.com
 */
public interface LinkedSegment extends Segment {

	/*
	 * Date: 13 Nov 2023 -----------------------------------------------------------
	 * Time created: 12:18:16 ---------------------------------------------------
	 */
	/**
	 * Gets the index of any superscript {@code LinkedSegment} or returns {@code -1} if this
	 * {@code LinkedSegment} does not support superscript indexes. A superscript {@code LinkedSegment} is a
	 * {@code LinkedSegment} that is visually represented above this {@code LinkedSegment}. For example, in the
	 * summing function:
	 * 
	 * <div>
	 *	  <svg height="70" width="200">
	 *	  	<text x="25" y="12" fill="black" style="font-size:10px;font-family:serif;font-weight:400;font-style:oblique;">n</text>
	 *	  	<text x="20" y="35" fill="black" style="font-size:30px;font-family:serif;font-weight:400;">&#x03A3;</text>
	 *	  	<text x="20" y="45" fill="black" style="font-size:10px;font-family:serif;font-weight:400;font-style:oblique;">i=</text>
	 *	  	<text x="30" y="45" fill="black" style="font-size:10px;font-family:serif;font-weight:400;">3</text>
	 *	  	<text x="40" y="28" fill="black" style="font-size:15px;font-family:serif;font-weight:400;font-style:oblique;">i</text>
	 *	  	<text x="45" y="20" fill="black" style="font-size:10px;font-family:serif;font-weight:400;font-style:oblique;">n</text>
	 *	  </svg>
	 * </div>
	 * 
	 * the {@code LinkedSegment} {@code n} is the super-index of the {@code LinkedSegment}
	 * <code>&#x03A3;</code>, because it is visually represent on the northside of
	 * the sigma character. The index value is implementation dependent, in the
	 * summing function example, we can use {@code 0} to represent the super index
	 * of the sigma {@code LinkedSegment}. This means that calling {@link #getChildren()}, our
	 * superscript resides in the index {@code 0} within the returned array.
	 * <p>
	 * A {@code LinkedSegment} may only have just 1 super-index which may be a composite {@code LinkedSegment}
	 * (which may itself have an sub/super-index) or a simple scalar {@code LinkedSegment}.
	 * <p>
	 * Note that {@code LinkedSegment} objects are not required to always have sub/super-indexes,
	 * as we can see from the example above, some {@code LinkedSegment}s do not support
	 * sub/super-indexes (for example scalars such as digits or single letter
	 * variables do not support superscripts). See the documentation of concrete
	 * implementations to identify the location of superscript and subscript indexes
	 * or whether they even support any in the first place.
	 * 
	 * @return the non-negative index (within child {@code LinkedSegment}s) of the superscript
	 *         {@code LinkedSegment}. Returns {@code -1} if this {@code LinkedSegment} does not support
	 *         superscript indexes.
	 */
	int getSuperIndex();

	/*
	 * Date: 13 Nov 2023 -----------------------------------------------------------
	 * Time created: 12:18:16 ---------------------------------------------------
	 */
	/**
	 * Gets the index of any subscript {@code LinkedSegment} or returns {@code -1} if this {@code LinkedSegment}
	 * does not support subscript indexes. A subscript {@code LinkedSegment} is a {@code LinkedSegment} that is
	 * visually represented below this {@code LinkedSegment}. For example, in the summing
	 * function:
	 * 
	 * <div>
	 *	  <svg height="70" width="200">
	 *	  	<text x="25" y="12" fill="black" style="font-size:10px;font-family:serif;font-weight:400;font-style:oblique;">n</text>
	 *	  	<text x="20" y="35" fill="black" style="font-size:30px;font-family:serif;font-weight:400;">&#x03A3;</text>
	 *	  	<text x="20" y="45" fill="black" style="font-size:10px;font-family:serif;font-weight:400;font-style:oblique;">i=</text>
	 *	  	<text x="30" y="45" fill="black" style="font-size:10px;font-family:serif;font-weight:400;">3</text>
	 *	  	<text x="40" y="28" fill="black" style="font-size:15px;font-family:serif;font-weight:400;font-style:oblique;">i</text>
	 *	  	<text x="45" y="20" fill="black" style="font-size:10px;font-family:serif;font-weight:400;font-style:oblique;">n</text>
	 *	  </svg>
	 * </div>
	 * 
	 * the {@code LinkedSegment} {@code i=3} is the sub-index of the {@code LinkedSegment}
	 * <code>&#x03A3;</code>, because it is visually represent on the southside of
	 * the sigma character. The index value is implementation dependent, in the
	 * summing function example, if we use {@code 1} to represent the sub-index of
	 * the sigma {@code LinkedSegment}, calling {@link #getChildren()}, our subscript resides in
	 * the index {@code 1} within the returned array.
	 * <p>
	 * A {@code LinkedSegment} may only have just 1 sub-index which may be a {@code LinkedSegment} index (which
	 * may itself have a sub/super-index) or a simple scalar {@code LinkedSegment}.
	 * <p>
	 * Note that {@code LinkedSegment} objects are not required to always have sub/super-indexes,
	 * as we can see from the example above, some {@code LinkedSegment}s do not support
	 * sub/super-indexes (for example scalars such as digits or single letter
	 * variables do not support subscripts). See the documentation of concrete
	 * implementations to identify the location of superscript and subscript indexes
	 * or whether they even support any in the first place.
	 * 
	 * @return the non-negative index (within child {@code LinkedSegment}s) of the subscript
	 *         {@code LinkedSegment}. Returns {@code -1} if this {@code LinkedSegment} does not support
	 *         subscript indexes.
	 */
	int getSubIndex();

	/*
	 * Date: 13 Nov 2023 -----------------------------------------------------------
	 * Time created: 13:52:32 ---------------------------------------------------
	 */
	/**
	 * Gets the sibling of this {@code LinkedSegment}. If there is no sibling, then this value will be {@code null}.
	 * <p>Using the example of this class' documentation, we can retrieve the sibling by doing:
	 *<pre>
	 *	<code>
	 *		LinkedSegment plus = head.getSibling();//Gets the segment representing the visual '+'
	 *	</code>
	 *</pre>
	 * @return the sibling of this {@code LinkedSegment}, or {@code null} if no sibling exists here.
	 */
	LinkedSegment getSibling();

	/*
	 * Date: 14 Nov 2023 -----------------------------------------------------------
	 * Time created: 04:26:55 ---------------------------------------------------
	 */
	/**
	 * Gets the all the child {@code LinkedSegment}s of this {@code LinkedSegment} in an array in a given order.
	 * For example:
	 * <div>
	 * 	<svg viewbox="0 0 120 60">
	 * 		<rect x="23" rx="2" y="5" ry="2" width="10" stroke-width=".5" stroke="red" fill="none" height="9" />
	 * 		<rect x="18" rx="2" y="37" ry="2" width="19" stroke-width=".5" stroke="red" fill="none" height="10" />
	 * 		<rect x="39" rx="2" y="13" ry="2" width="13" stroke-width=".5" stroke="red" fill="none" height="17" />
	 * 		<text x="25" y="12" fill="black" style="font-size:10px;font-family:serif;font-weight:400;font-style:oblique;">n</text>
	 * 		<text x="20" y="35" fill="black" style="font-size:30px;font-family:serif;font-weight:400;">&#x03A3;</text>
	 * 		<text x="20" y="45" fill="black" style="font-size:10px;font-family:serif;font-weight:400;font-style:oblique;">i=</text>
	 * 		<text x="30" y="45" fill="black" style="font-size:10px;font-family:serif;font-weight:400;">3</text>
	 * 		<text x="40" y="28" fill="black" style="font-size:15px;font-family:serif;font-weight:400;font-style:oblique;">i</text>
	 * 		<text x="45" y="20" fill="black" style="font-size:10px;font-family:serif;font-weight:400;font-style:oblique;">n</text>
	 * 	</svg>
	 * </div>
	 * All the children of the visually represented {@code LinkedSegment} are placed in red boxes, and some children also have
	 * their own children such as {@code i}<sup><code>n</code></sup>.
	 * <p>This will return an empty array if this {@code LinkedSegment} does not have a child node.
	 * @return all the corresponding children of this {@code LinkedSegment}'s node.
	 */
	LinkedSegment[] getChildren();

	/*
	 * Date: 14 Nov 2023 -----------------------------------------------------------
	 * Time created: 05:36:04 ---------------------------------------------------
	 */
	/**
	 * Sets the focus of the {@code LinkedSegment} at the given index within the tree. Since {@code LinkedSegment}s are immutable,
	 * this method will return a new {@code LinkedSegment} which will have the same focus as the argument. Note that
	 * this method will not mutate the object on which it was called. Also note that certain applications
	 * may use the focus property to display visual caret for viewers of math.
	 * @param index the index of the {@code LinkedSegment} which will have it's focus set to the {@code boolean} value.
	 * @param f the focus to be set.
	 * @return a new {@code LinkedSegment} tree whereby the focus (specified by {@link #isFocused}) of the {@code LinkedSegment} at index
	 * is the same as the {@code boolean} argument.
	 * @throws IndexOutOfBoundsException if no {@code LinkedSegment} at the specified index exists.
	 */
	LinkedSegment setFocus(int index, boolean f) throws IndexOutOfBoundsException;

	/*
	 * Date: 14 Nov 2023 -----------------------------------------------------------
	 * Time created: 05:36:04 ---------------------------------------------------
	 */
	/**
	 * Sets the error property of the {@code LinkedSegment} at the given index within the tree. Since {@code LinkedSegment}s are immutable,
	 * this method will return a new {@code LinkedSegment} which will have the same error property as the argument. Note that
	 * this method will not mutate the object on which it was called and that certain applications
	 * may use the error property to display visuals for viewers of math.
	 * @param index the index of the {@code LinkedSegment} which will have it's error property set to the {@code boolean} value.
	 * @param e the error property to be set.
	 * @return a new {@code LinkedSegment} tree such that the {@code LinkedSegment} at the given index has the same error (specified by {@link #hasError})
	 * property as the {@code boolean} argument.
	 * @throws IndexOutOfBoundsException if no {@code LinkedSegment} at the specified index exists.
	 */
	LinkedSegment setError(int index, boolean e) throws IndexOutOfBoundsException;

	/*
	 * Date: 14 Nov 2023 -----------------------------------------------------------
	 * Time created: 05:36:04 ---------------------------------------------------
	 */
	/**
	 * Sets the sibling of the {@code LinkedSegment} at the specified index to the given {@code LinkedSegment} argument.
	 * This effectively deletes any sibling occupying this position hitherto.
	 * @param index the index of the {@code LinkedSegment} whose sibling is to be set.
	 * @param sibling the {@code LinkedSegment} that will be set as the sibling of the {@code LinkedSegment} at the index that was specified.
	 * Assigning {@code null} here will cause the {@code LinkedSegment} specified at the index to be deleted and it
	 * will not have a sibling afterwards.
	 * @return a new {@code LinkedSegment} tree whereby the {@code LinkedSegment} at the specified index has the {@code LinkedSegment} argument as it's sibling.
	 * @throws IndexOutOfBoundsException if no {@code LinkedSegment} at the specified index exists.
	 */
	LinkedSegment setSibling(int index, LinkedSegment sibling) throws IndexOutOfBoundsException;

	/*
	 * Date: 14 Nov 2023 -----------------------------------------------------------
	 * Time created: 06:36:39 ---------------------------------------------------
	 */
	/**
	 * Sets the child of this {@code LinkedSegment} at the given {@code childIndex} to the specified {@code LinkedSegment} value.
	 * @param childIndex the index of the child to be set.
	 * @param childToSet the {@code LinkedSegment} value that will be set as the new child at the given index of this {@code LinkedSegment}. If this value
	 * is {@code null} then this {@code LinkedSegment} will have no child at the specified index. Howbeit, this is
	 * is an unexpected behaviour.
	 * @return a new {@code LinkedSegment} tree whereby the child {@code LinkedSegment} at the specified index has the {@code LinkedSegment} argument as it's value.
	 * @throws IndexOutOfBoundsException if no {@code LinkedSegment} at the specified index exists.
	 */
	LinkedSegment setChild(int childIndex, LinkedSegment childToSet) throws IndexOutOfBoundsException;

	/*
	 * Date: 14 Nov 2023 -----------------------------------------------------------
	 * Time created: 06:48:28 ---------------------------------------------------
	 */
	/**
	 * Concatenates the argument to this tree. More plainly, sets the sibling of the last node
	 * (in this tree {@code LinkedSegment}) to the argument.
	 * <p>Using the example of this class' documentation, we can concatenate 2 {@code LinkedSegment} objects by doing:
	 *<pre>
	 *	<code>
	 *		LinkedSegment nine = head.getSibling().concat(Digits.integer('9', new DigitPunc()));//the segment representing the visual '+9'
	 *	</code>
	 *</pre>
	 * @param s the {@code LinkedSegment} to be concatenated to this tree. This value is non-null.
	 * @return a new {@code LinkedSegment} tree with the last node being the argument.
	 * @throws NullPointerException if the argument is {@code null}.
	 */
	LinkedSegment concat(LinkedSegment s) throws NullPointerException;

	/*
	 * Date: 14 Nov 2023 -----------------------------------------------------------
	 * Time created: 06:56:58 ---------------------------------------------------
	 */
	/**
	 * Calculates whether this {@code LinkedSegment} has a sibling and returns {@code true} if it is.
	 * Note that this will only return {@code false} if this is the last {@code LinkedSegment} in the
	 * {@code LinkedSegment} tree.
	 * @return {@code true} if and only if this has a sibling or else returns {@code false}.
	 */
	default boolean hasSibling() {
		return getSibling() != null;
	}

	/*
	 * Date: 14 Nov 2023 -----------------------------------------------------------
	 * Time created: 07:00:23 ---------------------------------------------------
	 */
	/**
	 * Calculates the number of siblings this {@code LinkedSegment} has and then adds one to the result and returns it.
	 * The child nodes are not counted.
	 * <p>Using the example of this class' documentation, we can get the length of the formula by doing:
	 *<pre>
	 *	<code>
	 *		int l = formula.length();
	 *		System.out.println(l);// prints 3
	 *	</code>
	 *</pre>
	 * <p>This method is analogous to {@link String#length}
	 * @return the number of horizontal (top-level) {@code LinkedSegment} nodes in this tree.
	 */
	default int length() {
		return 1 + (hasSibling() ? getSibling().length() : 0);
	}

	/*
	 * Date: 14 Nov 2023 -----------------------------------------------------------
	 * Time created: 07:02:24 ---------------------------------------------------
	 */
	/**
	 * Retrieves the {@code LinkedSegment} at the given index as an isolated {@code LinkedSegment}. An isolated
	 * {@code LinkedSegment} is one without a sibling. Throws an  exception if no {@code LinkedSegment} exists
	 * at the specified index.
	 * <p>Using the example of this class' documentation, we can retrieve the {@code LinkedSegment} at an index
	 * by doing:
	 *<pre>
	 *	<code>
	 *		LinkedSegment l = formula.get(1);//Gets the representation of '+'
	 *	</code>
	 *</pre>
	 * <p>This method runs parallel to {@link String#charAt}.
	 * @param index the index of the {@code LinkedSegment} to be retrieved.
	 * @return the {@code LinkedSegment} at the specified index.
	 * @throws IndexOutOfBoundsException if no {@code LinkedSegment} at the specified index exists.
	 */
	default LinkedSegment segmentAt(int index) throws IndexOutOfBoundsException {
		return subsegment(index, index + 1).setSibling(0, null);
	}

	/*
	 * May return an empty {@code LinkedSegment} if start == end and both are within bounds
	 */
	/*
	 * Date: 14 Nov 2023 -----------------------------------------------------------
	 * Time created: 07:08:23 ---------------------------------------------------
	 */
	/**Retrieves the {@code LinkedSegment} of the tree that starts from (and also includes) the
	 * first argument and ends at (but not including) the second argument. Will return
	 * the empty {@code LinkedSegment} if {@code start == end} and both argument are within the bounds
	 * of this tree.
	 * <p>This method is analogous to {@link String#substring(int, int)}
	 * @param from the index from which the the head of the returned {@code LinkedSegment} will be taken. This value is inclusive.
	 * @param to the index that is immediately after the tail of the returned {@code LinkedSegment}. This value is exclusive.
	 * @return a new {@code LinkedSegment} that is an element of this {@code LinkedSegment} tree within the given bounds. Will return
	 * a special empty {@code LinkedSegment} ({@code Empty}) if the first and second argument is within the
	 * range of this tree and both are equal.
	 * @throws IndexOutOfBoundsException if no {@code LinkedSegment} exists at any of the specified indexes.
	 */
	default LinkedSegment subsegment(int from, int to) throws IndexOutOfBoundsException {
		if (from > to)
			throw new IndexOutOfBoundsException("from > to");
		int length = length();
		if (from == to && (from >= 0 && from < length))
			return new Empty();
		if (from == 0) {
			if (to == length)
				return this;
			return setSibling(to - from - 1, null);
		} else if (to == length)
			return subsegment(from);
		return subsegment(from).setSibling(to - from - 1, null);
	}

	/*
	 * Date: 14 Nov 2023 -----------------------------------------------------------
	 * Time created: 07:28:28 ---------------------------------------------------
	 */
	/**
	 * Retrieves the {@code LinkedSegment} at the given index which will contain all {@code LinkedSegment}s that
	 * are it's siblings along with any/all their corresponding children.
	 * <p>This method is analogous to {@link String#substring(int)}
	 * @param fromIndex the index at which the {@code LinkedSegment} will be returned.
	 * @return a new {@code LinkedSegment} tree which exists at the given index prior to this
	 * method call.
	 * @throws IndexOutOfBoundsException if no {@code LinkedSegment} at the specified index exists.
	 */
	default LinkedSegment subsegment(int fromIndex) throws IndexOutOfBoundsException {
		if (fromIndex == 0)
			return this;
		else if (fromIndex > 0 && hasSibling())
			return getSibling().subsegment(fromIndex - 1);
		throw new IndexOutOfBoundsException();
	}
	
	/*
	 * Date: 14 Nov 2023 -----------------------------------------------------------
	 * Time created: 07:35:47 ---------------------------------------------------
	 */
	/**
	 * Formats this {@code LinkedSegment} and then traverses the {@code LinkedSegment} tree (permuting all the children)
	 * calling {@code format} for each {@code LinkedSegment} encountered. A {@code LinkedSegment} is formatted by
	 * transforming it's image into a display-language-specific (such as TeX, LaTeX, AsciiMath,
	 * MathML etc) string, storing the string in the given {@code Appendable} and then executing the
	 * same operation on the children. The formatter argument is used to create additional
	 * visual effects as desired.
	 * <p>This method does not (neither should it) mutate this {@code LinkedSegment}. Any side effects must be invisible
	 * to the caller if the {@code LinkedSegment} is used for further operations i.e none of the methods
	 * of this interface should behave differently after calling this method, hence this method may be called
	 * as many times as possible and still have a consistent behaviour. The only visible side effect is the strings written
	 * to the {@code Appendable} argument.
	 * @param a an {@code Appendable} that holds the final form after this method returns.
	 * @param f used for creating additional visual effects as desired.
	 * @param indexes acts as a reference for the index of each {@code LinkedSegment} encountered. This reference
	 * may be used by the formatter.
	 * @throws IndexOutOfBoundsException {@inheritDoc}
	 */
	@Override
	void format(Appendable a, Formatter f, List<Integer> indexes) throws IndexOutOfBoundsException;
	
	/*
	 * Date: 14 Nov 2023 -----------------------------------------------------------
	 * Time created: 07:46:49 ---------------------------------------------------
	 */
	/**
	 * Converts this {@code LinkedSegment} into a string executable by programs such as Symja, Mathematica etc,
	 * and then traverses the {@code LinkedSegment} tree (permuting all children) calling {@code toString(Appendable, Log, List)}
	 * for each {@code LinkedSegment} encountered. The converted string can be retrieved from the given Appendable.
	 * <p>This method does not (neither should it) mutate this {@code LinkedSegment}. Any side effects must be invisible
	 * to the caller if the {@code LinkedSegment} is used for further operations i.e none of the methods
	 * of this interface should behave differently after calling this method, hence this method may be called
	 * as many times as possible and still have a consistent behaviour. The only visible side effect is the strings written
	 * to the {@code Appendable} argument.
	 * @param a the value where the resultant string is stored.
	 * @param l an object used as a logging tool to inform the developer about for important infos,
	 * warnings and errors.
	 * @param indexes acts as a reference for the index of each {@code LinkedSegment} encountered. This reference
	 * may be used by the log.
	 * @throws IndexOutOfBoundsException {@inheritDoc}
	 */
	@Override
	void toString(Appendable a, Log l, List<Integer> indexes) throws IndexOutOfBoundsException;

	/*
	 * default LinkedSegment delete(int index) throws IndexOutOfBoundsException {
	 * if(index == 0) return new Empty(); return segmentAt(index -
	 * 1).setSibling(null); } default LinkedSegment delete(int from, int to) throws
	 * IndexOutOfBoundsException { if(from > to) throw new
	 * IndexOutOfBoundsException("from > to"); int length = length(); if(from == to
	 * && (from >= 0 && from < length) && (to >= 0 && to < length)) return this;
	 * if(from == 0) { if(to == length) return new Empty(); return segmentAt(to); }
	 * else if(to == length) return subsegment(from - 1, from); return
	 * segmentAt(from - 1).setSibling(to); }
	 */
}